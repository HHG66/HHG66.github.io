<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>解决跨域 | Hexo</title><meta name="keywords" content="博客"><meta name="author" content="Han Hongguang"><meta name="copyright" content="Han Hongguang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="10 种跨域解决方案（附终极方案）技术胖学程序 2021-12-08 13:15 以下文章来源于秋风的笔记 ，作者蓝色的秋风 写在前面嗯。又来了，又说到跨域了，这是一个老生常谈的话题，以前我觉得这种基础文章没有什么好写的，会想着你去了解底层啊，不是很简单吗。但是最近在开发一个 「vscode 插件」 发现，当你刚入门一样东西的时候，你不会想这么多，因为你对他不熟悉，当你遇到不会的东西，你就是想先找">
<meta property="og:type" content="article">
<meta property="og:title" content="解决跨域">
<meta property="og:url" content="http://example.com/2021/12/08/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="10 种跨域解决方案（附终极方案）技术胖学程序 2021-12-08 13:15 以下文章来源于秋风的笔记 ，作者蓝色的秋风 写在前面嗯。又来了，又说到跨域了，这是一个老生常谈的话题，以前我觉得这种基础文章没有什么好写的，会想着你去了解底层啊，不是很简单吗。但是最近在开发一个 「vscode 插件」 发现，当你刚入门一样东西的时候，你不会想这么多，因为你对他不熟悉，当你遇到不会的东西，你就是想先找">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2021-12-08T07:46:15.000Z">
<meta property="article:modified_time" content="2022-04-23T01:48:42.000Z">
<meta property="article:author" content="Han Hongguang">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/12/08/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '解决跨域',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-23 09:48:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">解决跨域</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-08T07:46:15.000Z" title="发表于 2021-12-08 15:46:15">2021-12-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-23T01:48:42.000Z" title="更新于 2022-04-23 09:48:42">2022-04-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="解决跨域"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="10-种跨域解决方案（附终极方案）"><a href="#10-种跨域解决方案（附终极方案）" class="headerlink" title="10 种跨域解决方案（附终极方案）"></a>10 种跨域解决方案（附终极方案）</h1><p><a href="javascript:void(0);">技术胖学程序</a> <em>2021-12-08 13:15</em></p>
<p>以下文章来源于秋风的笔记 ，作者蓝色的秋风</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>嗯。又来了，又说到跨域了，这是一个老生常谈的话题，以前我觉得这种基础文章没有什么好写的，会想着你去了解底层啊，不是很简单吗。但是最近在开发一个 <strong>「vscode 插件」</strong> 发现，当你刚入门一样东西的时候，你不会想这么多，因为你对他不熟悉，当你遇到不会的东西，你就是想先找到解决方案，然后通过这个解决方案再去深入理解。就比如跨域，新人或者刚接触的人对它并不是那么熟悉，所以说列出一些自己积累的方案，以及一些常用的场景来给他人带来一些解决问题的思路，这件事是有意义的。（写完之后还发现真香。以后忘了还能回来看看）</p>
<p>其实现在的环境对于刚入门的前端来说，非常的不友好，一方面吧，很多刚新人没有经历过工具的变更时代，另一方面框架的迭代更新速度很快。在以前你可能掌握几种常见的手法就好了。但是现在 <code>webpack-dev-server</code>、<code>vue-cli</code>、<code>parcel</code>，这些脚手架都进行了一层封装，对于熟悉的人可能很简单，但是对于还未入门的人来说，简直就是一个黑盒，虽然用起来很方便，但是某一天遇到了问题，你对它不熟悉，你就会不知道所错。（但是别慌，主流 cli 的跨域方式我都会讲到）</p>
<p>讲着讲着有点偏离方向，可能我讲的也并不一定是正确的。下面切入正题。</p>
<p>本文会以 <strong>「「What-How-Why」」</strong> 的方式来进行讲解。而在在 How （如何解决跨域，将会提供标题的 11 种方案。）</p>
<p><strong>「重要的说明: 在文中，web 端地址为 localhost:8000 服务端地址为 localhost:8080,这一点希望你能记住，会贯穿全文，你也可以把此处的两端的地址代入你自己的地址。」</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Ezky0124ibExS4FicXQrkU1wSZwdGjHjVIUVlgnRZic5xy5VdrWYnWWib2N0P7ARFicY8Z39hBoRXjqgb07Cics4qoww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">cors</p>
<p>以下所有代码均在 <a target="_blank" rel="noopener" href="https://github.com/hua1995116/node-demo/tree/master/node-cors">https://github.com/hua1995116/node-demo/tree/master/node-cors</a></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Ezky0124ibExS4FicXQrkU1wSZwdGjHjVIBaKkxy6twy4981dt8Bty1ALN7ibrMvbtVVU5Gqo4fKCC5QcnI4jpPAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="一、跨域是什么？"><a href="#一、跨域是什么？" class="headerlink" title="一、跨域是什么？"></a>一、跨域是什么？</h2><h3 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1.同源策略"></a>1.同源策略</h3><p>跨域问题其实就是浏览器的同源策略所导致的。</p>
<blockquote>
<p>❝</p>
<p><strong>「同源策略」</strong>是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p>
<p>–来源 MDN</p>
<p>❞</p>
</blockquote>
<p>当跨域时会收到以下错误</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Ezky0124ibExS4FicXQrkU1wSZwdGjHjVIxPzJ1ZLoHn11rjsKC0aKJA775giccGiaYPIictfiaZOfLoiaWQJ9icvBJaTQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="2-同源示例"><a href="#2-同源示例" class="headerlink" title="2.同源示例"></a>2.同源示例</h3><p>那么如何才算是同源呢？先来看看 url 的组成部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Ezky0124ibExS4FicXQrkU1wSZwdGjHjVIlDpibdxrJLuAFkTKy9VWrYpmNehTU4bpnDE4AEv54pVuhFjqvTQXkWw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>只有当</p>
<p><strong>「protocol（协议）、domain（域名）、port（端口）三者一致。」</strong></p>
<p><strong>「protocol（协议）、domain（域名）、port（端口）三者一致。」</strong></p>
<p><strong>「protocol（协议）、domain（域名）、port（端口）三者一致。」</strong></p>
<p>才是同源。</p>
<p>以下协议、域名、端口一致。</p>
<p><a target="_blank" rel="noopener" href="http://www.example.com/a.js">http://www.example.com:80/a.js</a></p>
<p><a target="_blank" rel="noopener" href="http://www.example.com/b.js">http://www.example.com:80/b.js</a></p>
<p>以下这种看上去再相似也没有用，都不是同源。</p>
<p><a target="_blank" rel="noopener" href="http://www.example.com:8080/">http://www.example.com:8080</a></p>
<p><a target="_blank" rel="noopener" href="http://www2.example.com/">http://www2.example.com:80</a></p>
<p>在这里注意一下啊，这里是为了突出端口的区别才写上端口。在默认情况下 http 可以省略端口 80， https 省略 443。这别到时候闹笑话了，你和我说 <a target="_blank" rel="noopener" href="http://www.example.com/">http://www.example.com:80</a> 和 <a target="_blank" rel="noopener" href="http://www.example.com/">http://www.example.com</a> 不是同源，他俩是一个东西。</p>
<p><a target="_blank" rel="noopener" href="http://www.example.com/">http://www.example.com:80</a> === <a target="_blank" rel="noopener" href="http://www.example.com/">http://www.example.com</a></p>
<p><a target="_blank" rel="noopener" href="https://www.example.com/">https://www.example.com:443</a> === <a target="_blank" rel="noopener" href="https://www.example.com/">https://www.example.com</a></p>
<p>唔，还是要说明一下。</p>
<h2 id="二、如何解决跨域？"><a href="#二、如何解决跨域？" class="headerlink" title="二、如何解决跨域？"></a>二、如何解决跨域？</h2><h3 id="1-CORS"><a href="#1-CORS" class="headerlink" title="1.CORS"></a>1.CORS</h3><p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器<strong>「不同的域、协议或端口」</strong>请求一个资源时，资源会发起一个<strong>「跨域 HTTP 请求」</strong>。</p>
<p>而在 cors 中会有 <code>简单请求</code> 和 <code>复杂请求</code>的概念。</p>
<p><strong>「浏览器支持情况」</strong></p>
<p>当你使用 IE&lt;=9, Opera&lt;12, or Firefox&lt;3.5 或者更加老的浏览器，这个时候请使用 JSONP 。</p>
<h4 id="a-简单请求"><a href="#a-简单请求" class="headerlink" title="a.简单请求"></a>a.简单请求</h4><p>不会触发 CORS 预检请求。这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：</p>
<p>情况一: 使用以下方法(意思就是以下请求意外的都是非简单请求)</p>
<ul>
<li><code>GET</code></li>
<li><code>HEAD</code></li>
<li><code>POST</code></li>
</ul>
<p>情况二: 人为设置以下集合外的请求头</p>
<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
<li><code>Content-Type</code> （需要注意额外的限制）</li>
<li><code>DPR</code></li>
<li><code>Downlink</code></li>
<li><code>Save-Data</code></li>
<li><code>Viewport-Width</code></li>
<li><code>Width</code></li>
</ul>
<p>情况三：<code>Content-Type</code>的值仅限于下列三者之一：(例如 application/json 为非简单请求)</p>
<ul>
<li><code>text/plain</code></li>
<li><code>multipart/form-data</code></li>
<li><code>application/x-www-form-urlencoded</code></li>
</ul>
<p>情况四:</p>
<p>请求中的任意<code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；<code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。</p>
<p>情况五:</p>
<p>请求中没有使用 <code>ReadableStream</code> 对象。</p>
<h4 id="b-非简单请求"><a href="#b-非简单请求" class="headerlink" title="b.非简单请求"></a>b.非简单请求</h4><p>除以上情况外的。</p>
<h4 id="c-Node-中的解决方案"><a href="#c-Node-中的解决方案" class="headerlink" title="c.Node 中的解决方案"></a>c.Node 中的解决方案</h4><h5 id="原生方式"><a href="#原生方式" class="headerlink" title="原生方式"></a>原生方式</h5><p>我们来看下后端部分的解决方案。<code>Node</code> 中 <code>CORS</code> 的解决代码.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.set(&quot;Access-Control-Allow-Origin&quot;, ctx.headers.origin);</span><br><span class="line">  ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);</span><br><span class="line">  ctx.set(&quot;Access-Control-Request-Method&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line">  ctx.set(</span><br><span class="line">    &quot;Access-Control-Allow-Headers&quot;,</span><br><span class="line">    &quot;Origin, X-Requested-With, Content-Type, Accept, cc&quot;</span><br><span class="line">  );</span><br><span class="line">  if (ctx.method === &quot;OPTIONS&quot;) &#123;</span><br><span class="line">    ctx.status = 204;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  await next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h5><p>为了方便也可以直接使用中间件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const cors = require(&quot;koa-cors&quot;);</span><br><span class="line"></span><br><span class="line">app.use(cors());</span><br></pre></td></tr></table></figure>

<h5 id="关于-cors-的-cookie-问题"><a href="#关于-cors-的-cookie-问题" class="headerlink" title="关于 cors 的 cookie 问题"></a>关于 cors 的 cookie 问题</h5><p>想要传递 <code>cookie</code> 需要满足 3 个条件</p>
<p>1.web 请求设置<code>withCredentials</code></p>
<p>这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 <code>withCredentials</code> 来进行传递 <code>cookie</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 原生 xml 的设置方式</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line">// axios 设置方式</span><br><span class="line">axios.defaults.withCredentials = true;</span><br></pre></td></tr></table></figure>

<p>2.<code>Access-Control-Allow-Credentials</code> 为 <code>true</code></p>
<p>3.<code>Access-Control-Allow-Origin</code>为非 <code>*</code></p>
<p>这里请求的方式，在 <code>chrome</code> 中是能看到返回值的，但是只要不满足以上其一，浏览器会报错，获取不到返回值。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Ezky0124ibExS4FicXQrkU1wSZwdGjHjVIWd9AFdS7IGwonvqQA0jV0E9uoz0NatAgMVY2asWNZB2oGLclfWuROg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://127.0.0.1:8080/api/corslist&#x27; from origin &#x27;http://127.0.0.1:8000&#x27; has been blocked by CORS policy: The value of the &#x27;Access-Control-Allow-Credentials&#x27; header in the response is &#x27;&#x27; which must be &#x27;true&#x27; when the request&#x27;s credentials mode is &#x27;include&#x27;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Ezky0124ibExS4FicXQrkU1wSZwdGjHjVIdWKb69n2ic5qHOib0elFMID4xCOicY7fiajSEiblGXl5hN2fDErPriawWibRw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://127.0.0.1:8080/api/corslist&#x27; from origin &#x27;http://127.0.0.1:8000&#x27; has been blocked by CORS policy: The value of the &#x27;Access-Control-Allow-Origin&#x27; header in the response must not be the wildcard &#x27;*&#x27; when the request&#x27;s credentials mode is &#x27;include&#x27;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Ezky0124ibExS4FicXQrkU1wSZwdGjHjVI3SkWyshahSKr3Vw6mx0ArwXEekJVgUCKmyricmicqn0fId1bLD1adPVA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="d-前端示例"><a href="#d-前端示例" class="headerlink" title="d.前端示例"></a>d.前端示例</h4><p>分别演示一下前端部分 <code>简单请求</code> 和 <code>非简单请求</code></p>
<h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  axios.get(&quot;http://127.0.0.1:8080/api/corslist&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h5><p>这里我们加入了一个非集合内的 <code>header</code> 头 <code>cc</code> 来达到非简单请求的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  axios.get(&quot;http://127.0.0.1:8080/api/corslist&quot;, &#123; header: &#123; cc: &quot;xxx&quot; &#125; &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Ezky0124ibExS4FicXQrkU1wSZwdGjHjVIE4jjomSAC9jM0CqKZsXM4hEugZ48RaTyGHjKCZjqVkT5zhCzBQI5Zg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Ezky0124ibExS4FicXQrkU1wSZwdGjHjVIB28Yia7lcTAzAuVQTSwj0Oo8H5NaItFdFLbNVECrbs5ceiboHtkkjIXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>1、 在新版的 chrome 中，如果你发送了复杂请求，你却看不到 <code>options</code> 请求。可以在这里设置 <code>chrome://flags/#out-of-blink-cors</code> 设置成 <code>disbale</code> ，重启浏览器。对于非简单请求就能看到 <code>options</code> 请求了。</p>
<p>2、 一般情况下后端接口是不会开启这个跨域头的，除非是一些与用户无关的不太重要的接口。</p>
<h3 id="2-Node-正向代理"><a href="#2-Node-正向代理" class="headerlink" title="2.Node 正向代理"></a>2.Node 正向代理</h3><p>代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域。</p>
<p><strong>「代理前」</strong></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p><strong>「代理后」</strong></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>这样，所有的资源以及请求都在一个域名下了。</p>
<h4 id="a-cli-工具中的代理"><a href="#a-cli-工具中的代理" class="headerlink" title="a.cli 工具中的代理"></a>a.cli 工具中的代理</h4><h5 id="1-Webpack-4-x"><a href="#1-Webpack-4-x" class="headerlink" title="1) Webpack (4.x)"></a>1) Webpack (4.x)</h5><p>在<code>webpack</code>中可以配置<code>proxy</code>来快速获得接口代理的能力。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;  entry: &#123;    index: &quot;./index.js&quot;  &#125;,  output: &#123;    filename: &quot;bundle.js&quot;,    path: path.resolve(__dirname, &quot;dist&quot;)  &#125;,  devServer: &#123;    port: 8000,    proxy: &#123;      &quot;/api&quot;: &#123;        target: &quot;http://localhost:8080&quot;      &#125;    &#125;  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      filename: &quot;index.html&quot;,      template: &quot;webpack.html&quot;    &#125;)  ]&#125;;</span><br></pre></td></tr></table></figure>

<p>修改前端接口请求方式，改为不带域名。（因为现在是同域请求了）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;getlist&quot;&gt;获取列表&lt;/button&gt;&lt;button id=&quot;login&quot;&gt;登录&lt;/button&gt;&lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  axios.defaults.withCredentials = true;  getlist.onclick = () =&gt; &#123;    axios.get(&quot;/api/corslist&quot;).then(res =&gt; &#123;      console.log(res.data);    &#125;);  &#125;;  login.onclick = () =&gt; &#123;    axios.post(&quot;/api/login&quot;);  &#125;;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-Vue-cli-2-x"><a href="#2-Vue-cli-2-x" class="headerlink" title="2) Vue-cli 2.x"></a>2) Vue-cli 2.x</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// config/index.js...proxyTable: &#123;  &#x27;/api&#x27;: &#123;     target: &#x27;http://localhost:8080&#x27;,  &#125;&#125;,...</span><br></pre></td></tr></table></figure>

<h5 id="3-Vue-cli-3-x"><a href="#3-Vue-cli-3-x" class="headerlink" title="3) Vue-cli 3.x"></a>3) Vue-cli 3.x</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js 如果没有就新建module.exports = &#123;  devServer: &#123;    port: 8000,    proxy: &#123;      &quot;/api&quot;: &#123;        target: &quot;http://localhost:8080&quot;      &#125;    &#125;  &#125;&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="4-Parcel-2-x"><a href="#4-Parcel-2-x" class="headerlink" title="4) Parcel (2.x)"></a>4) Parcel (2.x)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// .proxyrc&#123;  &quot;/api&quot;: &#123;    &quot;target&quot;: &quot;http://localhost:8080&quot;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里，心里一句 xxx 就会脱口而出，一会写配置文件，一会 proxyTable ，一会 proxy，怎么这么多的形式？学不动了学不动了。。。不过也不用慌，还是有方法的。以上所有配置都是有着共同的底层包 http-proxy-middleware .里面需要用到的各种 <code>websocket</code> ，<code>rewrite</code> 等功能，直接看这个库的配置就可以了。关于 http-proxy-middleware 这个库的原理可以看我这篇文章 <a target="_blank" rel="noopener" href="https://github.com/hua1995116/proxy">https://github.com/hua1995116/proxy</a> 当然了。。。对于配置的位置入口还是非统一的。教一个搜索的技巧吧，上面配置写哪里都不用记的，想要哪个框架的 直接 google 搜索 xxx proxy 就行了。</p>
<p>例如 vue-cli 2 proxy 、 webpack proxy 等等….基本会搜到有官网的配置答案，通用且 nice。</p>
<h4 id="b-使用自己的代理工具"><a href="#b-使用自己的代理工具" class="headerlink" title="b.使用自己的代理工具"></a>b.使用自己的代理工具</h4><p>cors-anywhere</p>
<p><strong>「服务端」</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Listen on a specific host via the HOST environment variablevar host = process.env.HOST || &quot;0.0.0.0&quot;;// Listen on a specific port via the PORT environment variablevar port = process.env.PORT || 7777;var cors_proxy = require(&quot;cors-anywhere&quot;);cors_proxy  .createServer(&#123;    originWhitelist: [], // Allow all origins    requireHeader: [&quot;origin&quot;, &quot;x-requested-with&quot;],    removeHeaders: [&quot;cookie&quot;, &quot;cookie2&quot;]  &#125;)  .listen(port, host, function() &#123;    console.log(&quot;Running CORS Anywhere on &quot; + host + &quot;:&quot; + port);  &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>「前端代码」</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  axios.defaults.withCredentials = true;  getlist.onclick = () =&gt; &#123;    axios      .get(&quot;http://127.0.0.1:7777/http://127.0.0.1:8080/api/corslist&quot;)      .then(res =&gt; &#123;        console.log(res.data);      &#125;);  &#125;;  login.onclick = () =&gt; &#123;    axios.post(&quot;http://127.0.0.1:7777/http://127.0.0.1:8080/api/login&quot;);  &#125;;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>「效果展示」</strong></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p><strong>「缺点」</strong></p>
<p>无法专递 cookie，原因是因为这个是一个代理库，作者觉得中间传递 cookie 太不安全了。<a target="_blank" rel="noopener" href="https://github.com/Rob--W/cors-anywhere/issues/208#issuecomment-575254153">https://github.com/Rob--W/cors-anywhere/issues/208#issuecomment-575254153</a></p>
<h4 id="c-charles"><a href="#c-charles" class="headerlink" title="c.charles"></a>c.charles</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>这是一个测试、开发的神器。介绍与使用</p>
<p>利用 charles 进行跨域，本质就是请求的拦截与代理。</p>
<p>在 <code>tools/map remote</code> 中设置代理</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<h5 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;getlist&quot;&gt;获取列表&lt;/button&gt;&lt;button id=&quot;login&quot;&gt;登录&lt;/button&gt;&lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  axios.defaults.withCredentials = true;  getlist.onclick = () =&gt; &#123;    axios.get(&quot;/api/corslist&quot;).then(res =&gt; &#123;      console.log(res.data);    &#125;);  &#125;;  login.onclick = () =&gt; &#123;    axios.post(&quot;/api/login&quot;);  &#125;;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.get(&quot;/api/corslist&quot;, async ctx =&gt; &#123;  ctx.body = &#123;    data: [&#123; name: &quot;秋风的笔记&quot; &#125;]  &#125;;&#125;);router.post(&quot;/api/login&quot;, async ctx =&gt; &#123;  ctx.cookies.set(&quot;token&quot;, token, &#123;    expires: new Date(+new Date() + 1000 * 60 * 60 * 24 * 7)  &#125;);  ctx.body = &#123;    msg: &quot;成功&quot;,    code: 0  &#125;;&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><p>访问 <a target="_blank" rel="noopener" href="http://localhost:8000/charles">http://localhost:8000/charles</a></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>完美解决。</p>
<p>唔。这里又有一个注意点。在 <code>Mac mojave 10.14</code> 中会出现 <code>charles</code> 抓不到本地包的情况。这个时候需要自定义一个域名，然后配置<code>hosts</code>指定到<code>127.0.0.1</code>。然后修改访问方式 <code>http://localhost.charlesproxy.com:8000/charles</code>。</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<h3 id="3-Nginx-反向代理"><a href="#3-Nginx-反向代理" class="headerlink" title="3.Nginx 反向代理"></a>3.Nginx 反向代理</h3><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>Nginx 则是通过反向代理的方式，（这里也需要自定义一个域名）这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。nginx 安装教程</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>配置下 hosts</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 local.test</span><br></pre></td></tr></table></figure>

<p>配置 nginx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server &#123;        listen 80;        server_name local.test;        location /api &#123;            proxy_pass http://localhost:8080;        &#125;        location / &#123;            proxy_pass http://localhost:8000;        &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>启动 nginx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx</span><br></pre></td></tr></table></figure>

<p>重启 nginx</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure>

<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>前端代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  axios.defaults.withCredentials = true;  getlist.onclick = () =&gt; &#123;    axios.get(&quot;/api/corslist&quot;).then(res =&gt; &#123;      console.log(res.data);    &#125;);  &#125;;  login.onclick = () =&gt; &#123;    axios.post(&quot;/api/login&quot;);  &#125;;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>后端代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.get(&quot;/api/corslist&quot;, async ctx =&gt; &#123;  ctx.body = &#123;    data: [&#123; name: &quot;秋风的笔记&quot; &#125;]  &#125;;&#125;);router.post(&quot;/api/login&quot;, async ctx =&gt; &#123;  ctx.cookies.set(&quot;token&quot;, token, &#123;    expires: new Date(+new Date() + 1000 * 60 * 60 * 24 * 7)  &#125;);  ctx.body = &#123;    msg: &quot;成功&quot;,    code: 0  &#125;;&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h5><p>访问 <code>http://local.test/charles</code></p>
<p>浏览器显示</p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<h3 id="4-JSONP"><a href="#4-JSONP" class="headerlink" title="4.JSONP"></a>4.JSONP</h3><p><code>JSONP</code> 主要就是利用了 <code>script</code> 标签没有跨域限制的这个特性来完成的。</p>
<p><strong>「使用限制」</strong></p>
<p>仅支持 GET 方法，如果想使用完整的 REST 接口，请使用 CORS 或者其他代理方式。</p>
<p><strong>「流程解析」</strong></p>
<p>1.前端定义解析函数（例如 jsonpCallback=function(){….}）</p>
<p>2.通过 params 形式包装请求参数，并且声明执行函数(例如 cb=jsonpCallback)</p>
<p>3.后端获取前端声明的执行函数（jsonpCallback），并以带上参数并调用执行函数的方式传递给前端。</p>
<p><strong>「使用示例」</strong></p>
<p>后端实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&quot;koa&quot;);const fs = require(&quot;fs&quot;);const app = new Koa();app.use(async (ctx, next) =&gt; &#123;  if (ctx.path === &quot;/api/jsonp&quot;) &#123;    const &#123; cb, msg &#125; = ctx.query;    ctx.body = `$&#123;cb&#125;($&#123;JSON.stringify(&#123; msg &#125;)&#125;)`;    return;  &#125;&#125;);app.listen(8080);</span><br></pre></td></tr></table></figure>

<p>普通 js 示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  window.jsonpCallback = function(res) &#123;    console.log(res);  &#125;;&lt;/script&gt;&lt;script  src=&quot;http://localhost:8080/api/jsonp?msg=hello&amp;cb=jsonpCallback&quot;  type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>JQuery Ajax 示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.5.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  $.ajax(&#123;    url: &quot;http://localhost:8080/api/jsonp&quot;,    dataType: &quot;jsonp&quot;,    type: &quot;get&quot;,    data: &#123;      msg: &quot;hello&quot;    &#125;,    jsonp: &quot;cb&quot;,    success: function(data) &#123;      console.log(data);    &#125;  &#125;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>「原理解析」</strong></p>
<p>其实这就是 js 的魔法</p>
<p>我们先来看最简单的 js 调用。嗯，很自然的调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  window.jsonpCallback = function(res) &#123;    console.log(res);  &#125;;&lt;/script&gt;&lt;script&gt;  jsonpCallback(&#123; a: 1 &#125;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>我们稍稍改造一下，外链的形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.jsonpCallback = function(res) &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://localhost:8080/api/a.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// http://localhost:8080/api/a.js jsonpCallback(&#123;a:1&#125;);</span><br></pre></td></tr></table></figure>

<p>我们再改造一下，我们把这个外链的 js 就当做是一个动态的接口，因为本身资源和接口一样，是一个请求，也包含各种参数，也可以动态化返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.jsonpCallback = function(res) &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://localhost:8080/api/a.js?a=123&amp;cb=sonpCallback&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// http://localhost:8080/api/a.js jsonpCallback(&#123;a:123&#125;);</span><br></pre></td></tr></table></figure>

<p>你仔细品，细细品，是不是 jsonp 有的优势就是 script 加载 js 的优势，加载的方式只不过换了一种说法。这也告诉我们一个道理，很多东西并没有那么神奇，是在你所学的知识范围内。就好比，桃树和柳树，如果你把他们当成很大跨度的东西去记忆理解，那么世上这么多树，你真的要累死了，你把他们都当成是树，哦吼？你会突然发现，你对世界上所有的树都有所了解，他们都会长叶子，光合作用….当然也有个例，但是你只需要去记忆这些细微的差别，抓住主干。。。嗯，反正就这么个道理。</p>
<h3 id="5-Websocket"><a href="#5-Websocket" class="headerlink" title="5.Websocket"></a>5.Websocket</h3><p>WebSocket 规范定义了一种 API，可在网络浏览器和服务器之间建立“套接字”连接。简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。详细教程可以看 <a target="_blank" rel="noopener" href="https://www.html5rocks.com/zh/tutorials/websockets/basics/">https://www.html5rocks.com/zh/tutorials/websockets/basics/</a></p>
<p>这种方式本质没有使用了 HTTP, 因此也没有跨域的限制，没有什么过多的解释直接上代码吧。</p>
<p>前端部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let socket = new WebSocket(&quot;ws://localhost:8080&quot;);</span><br><span class="line">  socket.onopen = function() &#123;</span><br><span class="line">    socket.send(&quot;秋风的笔记&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  socket.onmessage = function(e) &#123;</span><br><span class="line">    console.log(e.data);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>后端部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const WebSocket = require(&quot;ws&quot;);</span><br><span class="line">const server = new WebSocket.Server(&#123; port: 8080 &#125;);</span><br><span class="line">server.on(&quot;connection&quot;, function(socket) &#123;</span><br><span class="line">  socket.on(&quot;message&quot;, function(data) &#123;</span><br><span class="line">    socket.send(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="6-window-postMessage"><a href="#6-window-postMessage" class="headerlink" title="6.window.postMessage"></a>6.window.postMessage</h3><p><strong>「window.postMessage()」</strong> 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 <code>Document.domain</code>设置为相同的值) 时，这两个脚本才能相互通信。<strong>「window.postMessage()」</strong> 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>1.页面和其打开的新窗口的数据传递</p>
<p>2.多窗口之间消息传递</p>
<p>3.页面与嵌套的 iframe 消息传递</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>详细用法看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure>

<ul>
<li>otherWindow: 其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。</li>
<li>message: 将要发送到其他 window 的数据。</li>
<li>targetOrigin: 通过窗口的 origin 属性来指定哪些窗口能接收到消息事件.</li>
<li>transfer(可选) : 是一串和 message 同时传递的 <code>Transferable</code> 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>index.html</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe</span><br><span class="line">  src=&quot;http://localhost:8080&quot;</span><br><span class="line">  frameborder=&quot;0&quot;</span><br><span class="line">  id=&quot;iframe&quot;</span><br><span class="line">  onload=&quot;load()&quot;</span><br><span class="line">&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  function load() &#123;</span><br><span class="line">    iframe.contentWindow.postMessage(&quot;秋风的笔记&quot;, &quot;http://localhost:8080&quot;);</span><br><span class="line">    window.onmessage = e =&gt; &#123;</span><br><span class="line">      console.log(e.data);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>another.html</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;hello&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.onmessage = e =&gt; &#123;</span><br><span class="line">    console.log(e.data); // 秋风的笔记</span><br><span class="line">    e.source.postMessage(e.data, e.origin);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="7-document-domain-Iframe"><a href="#7-document-domain-Iframe" class="headerlink" title="7.document.domain + Iframe"></a>7.document.domain + Iframe</h3><p>从第 7 种到第 9 种方式，我觉得别人的写的已经很好了，为了完整性，我就拿别人的了。如有雷同….（不对，就是雷同….）不要说不出来。</p>
<p><strong>「该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式」</strong>。只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">www.   baidu.  com     .</span><br><span class="line">三级域  二级域   顶级域   根域</span><br><span class="line">// a.test.com</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  helloa</span><br><span class="line">  &lt;iframe</span><br><span class="line">    src=&quot;http://b.test.com/b.html&quot;</span><br><span class="line">    frameborder=&quot;0&quot;</span><br><span class="line">    onload=&quot;load()&quot;</span><br><span class="line">    id=&quot;frame&quot;</span><br><span class="line">  &gt;&lt;/iframe&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    document.domain = &quot;test.com&quot;;</span><br><span class="line">    function load() &#123;</span><br><span class="line">      console.log(frame.contentWindow.a);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">// b.test.com</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  hellob</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    document.domain = &quot;test.com&quot;;</span><br><span class="line">    var a = 100;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-window-location-hash-Iframe"><a href="#8-window-location-hash-Iframe" class="headerlink" title="8.window.location.hash + Iframe"></a>8.window.location.hash + Iframe</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>原理就是通过 url 带 hash ，通过一个非跨域的中间页面来传递数据。</p>
<h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><p>一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。同样的，a.html 和 b.htm l 是同域的，都是 <code>http://localhost:8000</code>，而 c.html 是<code>http://localhost:8080</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line">&lt;iframe src=&quot;http://localhost:8080/hash/c.html#name1&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(location.hash);</span><br><span class="line">  window.onhashchange = function() &#123;</span><br><span class="line">    console.log(location.hash);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// b.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.parent.parent.location.hash = location.hash;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// c.html</span><br><span class="line">&lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(location.hash);</span><br><span class="line">  const iframe = document.createElement(&quot;iframe&quot;);</span><br><span class="line">  iframe.src = &quot;http://localhost:8000/hash/b.html#name2&quot;;</span><br><span class="line">  document.body.appendChild(iframe);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="9-window-name-Iframe"><a href="#9-window-name-Iframe" class="headerlink" title="9.window.name + Iframe"></a>9.window.name + Iframe</h3><p>window 对象的 name 属性是一个很特别的属性，当该 window 的 location 变化，然后重新加载，它的 name 属性可以依然保持不变。</p>
<p>其中 a.html 和 b.html 是同域的，都是<code>http://localhost:8000</code>，而 c.html 是<code>http://localhost:8080</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line">&lt;iframe</span><br><span class="line">  src=&quot;http://localhost:8080/name/c.html&quot;</span><br><span class="line">  frameborder=&quot;0&quot;</span><br><span class="line">  onload=&quot;load()&quot;</span><br><span class="line">  id=&quot;iframe&quot;</span><br><span class="line">&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let first = true;</span><br><span class="line">  // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br><span class="line">  function load() &#123;</span><br><span class="line">    if (first) &#123;</span><br><span class="line">      // 第1次onload(跨域页)成功后，切换到同域代理页面</span><br><span class="line">      iframe.src = &quot;http://localhost:8000/name/b.html&quot;;</span><br><span class="line">      first = false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span><br><span class="line">      console.log(iframe.contentWindow.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>b.html 为中间代理页，与 a.html 同域，内容为空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// b.html</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">// c.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.name = &quot;秋风的笔记&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h3 id="10-浏览器开启跨域（终极方案）"><a href="#10-浏览器开启跨域（终极方案）" class="headerlink" title="10.浏览器开启跨域（终极方案）"></a>10.浏览器开启跨域（终极方案）</h3><p>其实讲下其实跨域问题是浏览器策略，源头是他，那么能否能关闭这个功能呢？</p>
<p>答案是肯定的。</p>
<p><strong>「注意事项: 因为浏览器是众多 web 页面入口。我们是否也可以像客户端那种，就是用一个单独的专门宿主浏览器，来打开调试我们的开发页面。例如这里以 chrome canary 为例，这个是我专门调试页面的浏览器，不会用它来访问其他 web url。因此它也相对于安全一些。当然这个方式，只限于当你真的被跨域折磨地崩溃的时候才建议使用以下。使用后，请以正常的方式将他打开，以免你不小心用这个模式干了其他的事。」</strong></p>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找到你安装的目录</span><br><span class="line">.\Google\Chrome\Application\chrome.exe --disable-web-security --user-data-dir=xxxx</span><br></pre></td></tr></table></figure>

<h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><p><code>~/Downloads/chrome-data</code> 这个目录可以自定义.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Google\ Chrome\ Canary.app/Contents/MacOS/Google\ Chrome\ Canary  --disable-web-security --user-data-dir=~/Downloads/chrome-data</span><br></pre></td></tr></table></figure>

<h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>嗯，使用起来很香，但是再次提醒，一般情况千万别轻易使用这个方式，这个方式好比七伤拳，使用的好威力无比，使用不好，很容易伤到自己。</p>
<h2 id="三、为什么需要跨域？"><a href="#三、为什么需要跨域？" class="headerlink" title="三、为什么需要跨域？"></a>三、为什么需要跨域？</h2><p>在最一开始，我们知道了，跨域只存在于浏览器端。而浏览器为 web 提供访问入口。我们在可以浏览器内打开很多页面。正是这样的开放形态，所以我们需要对他有所限制。就比如林子大了，什么鸟都有，我们需要有一个统一的规范来进行约定才能保障这个安全性。</p>
<h3 id="1-限制不同源的请求"><a href="#1-限制不同源的请求" class="headerlink" title="1.限制不同源的请求"></a>1.限制不同源的请求</h3><p>这里还是用最常用的方式来讲解，例如用户登录 a 网站，同时新开 tab 打开了 b 网站，如果不限制同源， b 可以像 a 网站发起任何请求，会让不法分子有机可趁。</p>
<h3 id="2-限制-dom-操作"><a href="#2-限制-dom-操作" class="headerlink" title="2.限制 dom 操作"></a>2.限制 dom 操作</h3><p>我举个例子吧, 你先登录下 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> ,然后访问我这个网址。</p>
<p><a target="_blank" rel="noopener" href="https://zerolty.com/node-demo/index.html">https://zerolty.com/node-demo/index.html</a></p>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>你会发现，这个和真实的百度一模一样，如果再把域名搞的相似一些，是不是很容易被骗，如果可以进行 dom 操作…那么大家的信息在这种钓鱼网站眼里都是一颗颗小白菜，等着被收割。</p>
<blockquote>
<p>❝</p>
<p>可以在 http 返回头 添加<code>X-Frame-Options: SAMEORIGIN</code> 防止被别人添加至 iframe。</p>
<p>❞</p>
</blockquote>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>以上最常用的就是前 4 种方式，特别是第 2 种非常常见，我里面也提到了多种示例，大家可以慢慢消化一下。希望未来有更加安全的方式来限制 web ，解决跨域的头疼，哈哈哈哈。</p>
<p><strong>「有一个不成熟的想法，可以搞这么一个浏览器，只让访问内网/本地网络，专门给开发者用来调试页面用，对于静态资源可以配置白名单，这样是不是就没有跨域问题了，23333。上述如有错误，请第一时间指出，我会进行修改，以免给大家来误导。」</strong></p>
<p>**<br>**</p>
<p><strong>参考</strong></p>
<p><em><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12296910/so-jsonp-or-cors">https://stackoverflow.com/questions/12296910/so-jsonp-or-cors</a></em></p>
<p><em><a target="_blank" rel="noopener" href="https://juejin.im/post/5c23993de51d457b8c1f4ee1#heading-18">https://juejin.im/post/5c23993de51d457b8c1f4ee1#heading-18</a></em></p>
<p><em><a target="_blank" rel="noopener" href="https://juejin.im/post/5a6320d56fb9a01cb64ee191">https://juejin.im/post/5a6320d56fb9a01cb64ee191</a></em></p>
<p><em><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></em></p>
<p><em><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></em></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Han Hongguang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/12/08/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/">http://example.com/2021/12/08/%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8D%9A%E5%AE%A2/">博客</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/21/mongoose%E6%95%B0%E6%8D%AE%E5%BA%93/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">mongoose数据库</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/02/jstree%E6%A0%91%E6%8F%92%E4%BB%B6/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">jstree树插件</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/06/24/Ajax%E7%AC%94%E8%AE%B0/" title="Ajax笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-24</div><div class="title">Ajax笔记</div></div></a></div><div><a href="/2021/07/14/Bootstrap/" title="Bootstrap"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-14</div><div class="title">Bootstrap</div></div></a></div><div><a href="/2021/06/10/BUG%E8%AE%B0%E5%BD%95/" title="BUG记录"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">BUG记录</div></div></a></div><div><a href="/2021/11/10/JavaScript%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8/" title="JavaScript数组相关的方法使用"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-10</div><div class="title">JavaScript数组相关的方法使用</div></div></a></div><div><a href="/2021/07/12/JQuery%E7%AC%94%E8%AE%B0/" title="JQuery笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-12</div><div class="title">JQuery笔记</div></div></a></div><div><a href="/2021/06/09/PicGo%E5%9B%BE%E5%BA%8A%E4%BD%BF%E7%94%A8/" title="PicGo图床使用"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-09</div><div class="title">PicGo图床使用</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Han Hongguang</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E7%A7%8D%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E9%99%84%E7%BB%88%E6%9E%81%E6%96%B9%E6%A1%88%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">10 种跨域解决方案（附终极方案）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%B7%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">一、跨域是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%8C%E6%BA%90%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.同源示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">二、如何解决跨域？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CORS"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">a.简单请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E9%9D%9E%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">b.非简单请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-Node-%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">c.Node 中的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.3.1.</span> <span class="toc-text">原生方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">1.3.1.3.2.</span> <span class="toc-text">第三方中间件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-cors-%E7%9A%84-cookie-%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.1.3.3.</span> <span class="toc-text">关于 cors 的 cookie 问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-%E5%89%8D%E7%AB%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">d.前端示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-number">1.3.1.4.1.</span> <span class="toc-text">简单请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-number">1.3.1.4.2.</span> <span class="toc-text">非简单请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.1.4.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Node-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.Node 正向代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-cli-%E5%B7%A5%E5%85%B7%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">a.cli 工具中的代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Webpack-4-x"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">1) Webpack (4.x)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Vue-cli-2-x"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">2) Vue-cli 2.x</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Vue-cli-3-x"><span class="toc-number">1.3.2.1.3.</span> <span class="toc-text">3) Vue-cli 3.x</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Parcel-2-x"><span class="toc-number">1.3.2.1.4.</span> <span class="toc-text">4) Parcel (2.x)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">b.使用自己的代理工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-charles"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">c.charles</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.2.3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.2.3.2.</span> <span class="toc-text">前端代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.2.3.3.</span> <span class="toc-text">后端代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%88%E6%9E%9C"><span class="toc-number">1.3.2.3.4.</span> <span class="toc-text">效果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.Nginx 反向代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.3.3.0.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.0.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%88%E6%9E%9C-1"><span class="toc-number">1.3.3.0.3.</span> <span class="toc-text">效果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JSONP"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.JSONP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Websocket"><span class="toc-number">1.3.5.</span> <span class="toc-text">5.Websocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-window-postMessage"><span class="toc-number">1.3.6.</span> <span class="toc-text">6.window.postMessage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-document-domain-Iframe"><span class="toc-number">1.3.7.</span> <span class="toc-text">7.document.domain + Iframe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-window-location-hash-Iframe"><span class="toc-number">1.3.8.</span> <span class="toc-text">8.window.location.hash + Iframe</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">实现流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-window-name-Iframe"><span class="toc-number">1.3.9.</span> <span class="toc-text">9.window.name + Iframe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%80%E5%90%AF%E8%B7%A8%E5%9F%9F%EF%BC%88%E7%BB%88%E6%9E%81%E6%96%B9%E6%A1%88%EF%BC%89"><span class="toc-number">1.3.10.</span> <span class="toc-text">10.浏览器开启跨域（终极方案）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Windows"><span class="toc-number">1.3.10.1.</span> <span class="toc-text">Windows</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mac"><span class="toc-number">1.3.10.2.</span> <span class="toc-text">Mac</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA"><span class="toc-number">1.3.10.3.</span> <span class="toc-text">效果展示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">三、为什么需要跨域？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%99%90%E5%88%B6%E4%B8%8D%E5%90%8C%E6%BA%90%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.限制不同源的请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%99%90%E5%88%B6-dom-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.限制 dom 操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="toc-number">1.5.</span> <span class="toc-text">写在最后</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/03/ceshi/" title="ceshi"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ceshi"/></a><div class="content"><a class="title" href="/2022/05/03/ceshi/" title="ceshi">ceshi</a><time datetime="2022-05-03T11:41:25.000Z" title="发表于 2022-05-03 19:41:25">2022-05-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/23/TypeScipt%E5%AD%A6%E4%B9%A0/" title="TypeScipt学习"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TypeScipt学习"/></a><div class="content"><a class="title" href="/2022/04/23/TypeScipt%E5%AD%A6%E4%B9%A0/" title="TypeScipt学习">TypeScipt学习</a><time datetime="2022-04-23T01:47:37.000Z" title="发表于 2022-04-23 09:47:37">2022-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/04/ES6%E6%96%B0%E7%89%B9%E6%80%A7/" title="ES6新特性"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ES6新特性"/></a><div class="content"><a class="title" href="/2022/04/04/ES6%E6%96%B0%E7%89%B9%E6%80%A7/" title="ES6新特性">ES6新特性</a><time datetime="2022-04-04T12:43:12.000Z" title="发表于 2022-04-04 20:43:12">2022-04-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/01/MInIo%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89OSS/" title="MInIo搭建私有OSS"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MInIo搭建私有OSS"/></a><div class="content"><a class="title" href="/2022/04/01/MInIo%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89OSS/" title="MInIo搭建私有OSS">MInIo搭建私有OSS</a><time datetime="2022-04-01T11:31:47.000Z" title="发表于 2022-04-01 19:31:47">2022-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/25/node%E5%AD%A6%E4%B9%A0/" title="node学习"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="node学习"/></a><div class="content"><a class="title" href="/2022/03/25/node%E5%AD%A6%E4%B9%A0/" title="node学习">node学习</a><time datetime="2022-03-25T00:15:16.000Z" title="发表于 2022-03-25 08:15:16">2022-03-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Han Hongguang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>